{"name":"FluentDAO","tagline":"a dotnet database orm framework.forked from FluentData.","body":"# FluentDAO\r\na dotnet database orm framework.\r\n\r\n\r\nTable of Contents\r\n-----------------\r\n\r\n-   [Getting started](#GettingStarted)\r\n    -   [Requirements](#Requirements)\r\n    -   [Supported databases](#SupportedDatabases)\r\n    -   [Installation](#Installation)\r\n\r\n-   [Core concepts](#CoreConcepts)\r\n    -   [DbContext](#DbContext)\r\n    -   [DbCommand](#DbCommand)\r\n    -   [Events](#Events)\r\n    -   [Builders](#Builders)\r\n    -   [Mapping](#Mapping)\r\n    -   [When should you dispose?](#Dispose)\r\n\r\n-   [Code samples](#CodeSamples)\r\n    -   [Create and initialize a DbContext](#InitDbContext)\r\n    -   [Query for a list of items](#Query)\r\n    -   [Query for a single item](#QuerySingle)\r\n    -   [Query for a scalar value](#QueryValue)\r\n    -   [Query for a list of scalar values](#QueryValues)\r\n    -   [Parameters](#Parameters)\r\n    -   [Mapping](#CodeSamplesMapping)\r\n    -   [Multiple result sets](#MultiResultSets)\r\n    -   [Select data & Paging](#SelectData)\r\n    -   [Insert data](#InsertData)\r\n    -   [Update data](#UpdateData)\r\n    -   [Delete data](#DeleteData)\r\n    -   [Stored procedures](#StoredProcedures)\r\n    -   [Transactions](#Transactions)\r\n    -   [Entity factory](#EntityFactory)\r\n\r\nContents\r\n========\r\n\r\nGetting started\r\n---------------\r\n\r\n**Requirements**\r\n\r\n-   .NET 4.0.\r\n\r\n\\\r\n**Supported databases**\r\n\r\n-   MS SQL Server using the native .NET driver.\r\n-   MS SQL Azure using the native .NET driver.\r\n-   MS Access using the native .NET driver.\r\n-   MS SQL Server Compact 4.0 through the [Microsoft SQL Server Compact 4.0 driver](http://www.microsoft.com/download/en/details.aspx?id=17876).\r\n-   Oracle through the [ODP.NET driver](http://www.oracle.com/technetwork/topics/dotnet/index-085163.html).\r\n-   MySQL through the [MySQL Connector .NET driver](http://www.mysql.com/downloads/connector/net/).\r\n-   SQLite through the [SQLite ADO.NET Data Provider](http://system.data.sqlite.org/).\r\n-   PostgreSql through the [Npgsql](http://pgfoundry.org/projects/npgsql/) provider.\r\n-   IBM DB2\r\n\r\n\\\r\n**Installation**\\\r\nIf you are using NuGet:\r\n\r\n-   Search for LeadNT.FluentDAO and click Install.\r\n\r\nIf you are not using NuGet:\r\n\r\n1.  Download the zip with the binary files.\r\n2.  Extract it, and copy the files to your solution or project folder.\r\n3.  Add a project reference to  LeadNT.FluentDAO.dll.\r\n\r\nCore concepts\r\n-------------\r\n\r\n**DbContext**\\\r\nThis class is the starting point for working with FluentDAO. It has properties for defining configurations such as the connection string to the database, and operations for querying the database.\\\r\n\\\r\n**DbCommand**\\\r\nThis is the class that is responsible for performing the actual query against the database.\\\r\n\\\r\n**Events**\\\r\nThe DbContext class has support for the following events:\r\n\r\n-   OnConnectionClosed\r\n-   OnConnectionOpened\r\n-   OnConnectionOpening\r\n-   OnError\r\n-   OnExecuted\r\n-   OnExecuting\r\n\r\nBy using any of these then you can for instance write to the log if an error has occurred or when a query has been executed.\\\r\n\\\r\n**Builders**\\\r\nA builder provides a nice fluent API for generating SQL for insert, update and delete queries.\\\r\n\\\r\n**Mapping**\\\r\nFluentDAO can automap the result from a SQL query to either a dynamic type (new in .NET 4.0) or to your own .NET entity type (POCO - Plain Old CLR Object) by using the following convention:\\\r\n\\\r\nAutomap to an entity type:\r\n\r\n1.  If the field name does not contain an underscore (\"\\_\") then it will try to try to automap to a property with the same name. For instance a field named \"Name\" would be automapped to a property also named \"Name\".\r\n2.  If a field name does contain an underscore (\"*\") then it will try to map to a nested property. For instance a field named \"Category*Name\" would be automapped to the property \"Category.Name\".\r\n\r\nIf there is a mismatch between the fields in the database and in the entity type then the alias keyword in SQL can be used or you can create your own mapping method. Check the mapping section below for code samples.\\\r\n\\\r\nAutomap to a dynamic type:\r\n\r\n1.  For dynamic types every field will be automapped to a property with the same name. For instance the field name Name would be automapped to the Name property.\r\n\r\n\\\r\n**When should you dispose?**\r\n\r\n-   DbContext must be disposed if you have enabled UseTransaction or UseSharedConnection.\r\n-   DbCommand must be disposed if you have enabled UseMultiResult (or MultiResultSql).\r\n-   StoredProcedureBuilder must be disposed if you have enabled UseMultiResult.\r\n\r\nIn all the other cases dispose will be handled automatically by FluentDAO. This means that a database connection is opened just before a query is executed and closed just after the execution has been completed.\r\n\r\nCode samples\r\n------------\r\n\r\n**Create and initialize a DbContext**\\\r\nThe connection string on the DbContext class can be initialized either by giving the connection string name in the \\*.config file or by sending in the entire connection string.\\\r\n\\\r\n**Important configurations**\r\n\r\n-   IgnoreIfAutoMapFails - Calling this prevents automapper from throwing an exception if a column cannot be mapped to a corresponding property due to a name mismatch.\r\n\r\n\\\r\n**Create and initialize a DbContext**\\\r\nThe DbContext can be initialized by either calling ConnectionStringName which will read the connection string from the \\*.config file:\r\n\r\n    public IDbContext Context()\r\n    {\r\n        return new DbContext().ConnectionStringName(\"MyDatabase\",\r\n                new SqlServerProvider());\r\n    }\r\n\r\n\\\r\nor by calling the ConnectionString method to set the connection string explicitly:\r\n\r\n    public IDbContext Context()\r\n    {\r\n        return new DbContext().ConnectionString(\r\n        \"Server=MyServerAddress;Database=MyDatabase;Trusted_Connection=True;\", new SqlServerProvider());\r\n    }\r\n\r\n\\\r\n**Providers**\\\r\nIf you want to work against another database than SqlServer then simply replace the new SqlServerProvider() in the sample code above with any of the following:\\\r\nAccessProvider, DB2Provider, OracleProvider, MySqlProvider, PostgreSqlProvider, SqliteProvider, SqlServerCompact, SqlAzureProvider, SqlServerProvider.\\\r\n\\\r\n**Query for a list of items**\\\r\nReturn a list of dynamic objects (new in .NET 4.0):\r\n\r\n    List<dynamic> products = Context.Sql(\"select * from Product\").QueryMany<dynamic>();\r\n\r\n\\\r\nReturn a list of strongly typed objects:\r\n\r\n    List<Product> products = Context.Sql(\"select * from Product\").QueryMany<Product>();\r\n\r\n\\\r\nReturn a list of strongly typed objects in a custom collection:\r\n\r\n    ProductionCollection products = Context.Sql(\"select * from Product\").QueryMany<Product, ProductionCollection>();\r\n\r\n\\\r\nReturn a DataTable:\\\r\nSee Query for a single item.\\\r\n\\\r\n**Query for a single item**\\\r\n\\\r\nReturn as a dynamic object:\r\n\r\n    dynamic product = Context.Sql(@\"select * from Product\r\n                    where ProductId = 1\").QuerySingle<dynamic>();\r\n\r\n\\\r\nReturn as a strongly typed object:\r\n\r\n    Product product = Context.Sql(@\"select * from Product\r\n                where ProductId = 1\").QuerySingle<Product>();\r\n\r\n\\\r\nReturn as a DataTable:\r\n\r\n    DataTable products = Context.Sql(\"select * from Product\").QuerySingle<DataTable>();\r\n\r\nBoth QueryMany<DataTable\\> and QuerySingle<DataTable\\> can be called to return a DataTable, but since QueryMany returns a List<DataTable\\> then it's more convenient to call QuerySingle which returns just DataTable. Eventhough the method is called QuerySingle then multiple rows will still be returned as part of the DataTable.\\\r\n\\\r\n**Query for a scalar value**\r\n\r\n    int numberOfProducts = Context.Sql(@\"select count(*)\r\n                from Product\").QuerySingle<int>();\r\n\r\n\\\r\n**Query for a list of scalar values**\r\n\r\n    List<int> productIds = Context.Sql(@\"select ProductId\r\n                    from Product\").QueryMany<int>();\r\n\r\n\\\r\n**Parameters**\\\r\nIndexed parameters:\r\n\r\n    dynamic products = Context.Sql(@\"select * from Product\r\n                where ProductId = @0 or ProductId = @1\", 1, 2).QueryMany<dynamic>();\r\n\r\n\\\r\nor:\r\n\r\n    dynamic products = Context.Sql(@\"select * from Product\r\n                where ProductId = @0 or ProductId = @1\")\r\n                .Parameters(1, 2).QueryMany<dynamic>();\r\n\r\n\\\r\nNamed parameters:\r\n\r\n    dynamic products = Context.Sql(@\"select * from Product\r\n                where ProductId = @ProductId1 or ProductId = @ProductId2\")\r\n                .Parameter(\"ProductId1\", 1)\r\n                .Parameter(\"ProductId2\", 2)\r\n                .QueryMany<dynamic>();\r\n\r\n\\\r\nOutput parameter:\r\n\r\n    var command = Context.Sql(@\"select @ProductName = Name from Product\r\n                where ProductId=1\")\r\n                .ParameterOut(\"ProductName\", DataTypes.String, 100);\r\n    command.Execute();\r\n\r\n    string productName = command.ParameterValue<string>(\"ProductName\");\r\n\r\n\\\r\nList of parameters - in operator:\r\n\r\n    List<int> ids = new List<int>() { 1, 2, 3, 4 };\r\n    //becareful here,don't leave any whitespace around in(...) syntax.\r\n    dynamic products = Context.Sql(@\"select * from Product\r\n                where ProductId in(@0)\", ids).QueryMany<dynamic>();\r\n\r\n\\\r\nlike operator:\r\n\r\n    string cens = \"%abc%\";\r\n    Context.Sql(\"select * from Product where ProductName like @0\",cens);\r\n\r\n\\\r\n**Mapping**\\\r\nAutomapping - 1:1 match between the database and the .NET object:\r\n\r\n    List<Product> products = Context.Sql(@\"select *\r\n                from Product\")\r\n                .QueryMany<Product>();\r\n\r\n\\\r\nAutomap to a custom collection:\r\n\r\n    ProductionCollection products = Context.Sql(\"select * from Product\").QueryMany<Product, ProductionCollection>();\r\n\r\n\\\r\nAutomapping - Mismatch between the database and the .NET object, use the alias keyword in SQL:\\\r\nWeakly typed:\r\n\r\n    List<Product> products = Context.Sql(@\"select p.*,\r\n                c.CategoryId as Category_CategoryId,\r\n                c.Name as Category_Name\r\n                from Product p\r\n                inner join Category c on p.CategoryId = c.CategoryId\")\r\n                    .QueryMany<Product>();\r\n\r\nHere the p.\\* which is ProductId and Name would be automapped to the properties Product.Name and Product.ProductId, and Category\\_CategoryId and Category\\_Name would be automapped to Product.Category.CategoryId and Product.Category.Name.\\\r\n\\\r\nCustom mapping using dynamic:\r\n\r\n    List<Product> products = Context.Sql(@\"select * from Product\")\r\n                .QueryMany<Product>(Custom_mapper_using_dynamic);\r\n\r\n    public void Custom_mapper_using_dynamic(Product product, dynamic row)\r\n    {\r\n        product.ProductId = row.ProductId;\r\n        product.Name = row.Name;\r\n    }\r\n\r\n\\\r\nCustom mapping using a datareader:\r\n\r\n    List<Product> products = Context.Sql(@\"select * from Product\")\r\n                .QueryMany<Product>(Custom_mapper_using_datareader);\r\n\r\n    public void Custom_mapper_using_datareader(Product product, IDataReader row)\r\n    {\r\n        product.ProductId = row.GetInt32(\"ProductId\");\r\n        product.Name = row.GetString(\"Name\");\r\n    }\r\n\r\n\\\r\nOr if you have a complex entity type where you need to control how it is created then the QueryComplexMany/QueryComplexSingle can be used:\r\n\r\n    var products = new List<Product>();\r\n    Context.Sql(\"select * from Product\").QueryComplexMany<Product>(products, MapComplexProduct);\r\n\r\n    private void MapComplexProduct(IList<Product> products, IDataReader reader)\r\n    {\r\n        var product = new Product();\r\n        product.ProductId = reader.GetInt32(\"ProductId\");\r\n        product.Name = reader.GetString(\"Name\");\r\n        products.Add(product);\r\n    }\r\n\r\n\\\r\n**Multiple result sets**\\\r\nFluentDAO supports multiple resultsets. This allows you to do multiple queries in a single database call. When this feature is used it's important to wrap the code inside a using statement as shown below in order to make sure that the database connection is closed.\r\n\r\n    using (var command = Context.MultiResultSql)\r\n    {\r\n        List<Category> categories = command.Sql(\r\n                @\"select * from Category;\r\n                select * from Product;\").QueryMany<Category>();\r\n\r\n        List<Product> products = command.QueryMany<Product>();\r\n    }\r\n\r\nThe first time the Query method is called it does a single query against the database. The second time the Query is called, FluentDAO already knows that it's running in a multiple result set mode, so it reuses the data retrieved from the first query.\\\r\n\\\r\n**Select data and Paging**\\\r\nA select builder exists to make selecting data and paging easy:\r\n\r\n    List<Product> products = Context.Select<Product>(\"p.*, c.Name as Category_Name\")\r\n                       .From(@\"Product p \r\n                        inner join Category c on c.CategoryId = p.CategoryId\")\r\n                       .Where(\"p.ProductId > 0 and p.Name is not null\")\r\n                       .OrderBy(\"p.Name\")\r\n                       .Paging(1, 10).QueryMany();\r\n\r\nBy calling Paging(1, 10) then the first 10 products will be returned.\\\r\n\\\r\n**Insert data**\\\r\nUsing SQL:\r\n\r\n    int productId = Context.Sql(@\"insert into Product(Name, CategoryId)\r\n                values(@0, @1);\")\r\n                .Parameters(\"The Warren Buffet Way\", 1)\r\n                .ExecuteReturnLastId<int>();\r\n\r\n\\\r\nUsing a builder:\r\n\r\n    int productId = Context.Insert(\"Product\")\r\n                .Column(\"Name\", \"The Warren Buffet Way\")\r\n                .Column(\"CategoryId\", 1)\r\n                .ExecuteReturnLastId<int>();\r\n\r\n\\\r\nUsing a builder with automapping:\r\n\r\n    Product product = new Product();\r\n    product.Name = \"The Warren Buffet Way\";\r\n    product.CategoryId = 1;\r\n\r\n    product.ProductId = Context.Insert<Product>(\"Product\", product)\r\n                .AutoMap(x => x.ProductId)\r\n                .ExecuteReturnLastId<int>();\r\n\r\nWe send in ProductId to the AutoMap method to get AutoMap to ignore and not map the ProductId since this property is an identity field where the value is generated in the database.\\\r\n\\\r\n**Update data**\\\r\nUsing SQL:\r\n\r\n    int rowsAffected = Context.Sql(@\"update Product set Name = @0\r\n                where ProductId = @1\")\r\n                .Parameters(\"The Warren Buffet Way\", 1)\r\n                .Execute();\r\n\r\n\\\r\nUsing a builder:\r\n\r\n    int rowsAffected = Context.Update(\"Product\")\r\n                .Column(\"Name\", \"The Warren Buffet Way\")\r\n                .Where(\"ProductId\", 1)\r\n                .Execute();\r\n\r\n\\\r\nUsing a builder with automapping:\r\n\r\n    Product product = Context.Sql(@\"select * from Product\r\n                where ProductId = 1\")\r\n                .QuerySingle<Product>();\r\n    product.Name = \"The Warren Buffet Way\";\r\n\r\n    int rowsAffected = Context.Update<Product>(\"Product\", product)\r\n                .AutoMap(x => x.ProductId)\r\n                .Where(x => x.ProductId)\r\n                .Execute();\r\n\r\nWe send in ProductId to the AutoMap method to get AutoMap to ignore and not map the ProductId since this is the identity field that should not get updated.\\\r\n\\\r\n\\\r\n**IgnoreIfAutoMapFails**\\\r\nWhen read from database,If some data columns not mappinged with entity class,by default ,will throw exception.\\\r\n\\\r\nif you want ignore the exception, or the property not used for map data table,then you can use the IgnoreIfAutoMapFails(true),this will ignore the exception when read mapping error.\r\n\r\n    context.IgnoreIfAutoMapFails(true);\r\n\r\n\\\r\n\\\r\n**Ignore Attribute**\\\r\nAnd sometimes you need to add some extension property in entity class, when Insert/Update,will be exception,because not find the data column.on this time,you can add the [Ignore](/wikipage?title=Ignore&referringTitle=Documentation) to the special property,like this:\r\n\r\n    [Ignore]\r\n    public int TotalCount{get;set;}\r\n\r\n\\\r\nthis will skip the property when insert or update.\\\r\n\\\r\nso,if you used to extension entity class,the better way is use both context.IgnoreIfAutoMapFails and Ignore attribute.notice this maybe get wrong data and you can't catch easily.\\\r\n \\\r\n**Insert and update - common Fill method**\r\n\r\n    var product = new Product();\r\n    product.Name = \"The Warren Buffet Way\";\r\n    product.CategoryId = 1;\r\n\r\n    var insertBuilder = Context.Insert<Product>(\"Product\", product).Fill(FillBuilder);\r\n\r\n    var updateBuilder = Context.Update<Product>(\"Product\", product).Fill(FillBuilder);\r\n\r\n    public void FillBuilder(IInsertUpdateBuilder<Product> builder)\r\n    {\r\n        builder.Column(x => x.Name);\r\n        builder.Column(x => x.CategoryId);\r\n    }\r\n\r\n\\\r\n**Delete data**\\\r\nUsing SQL:\r\n\r\n    int rowsAffected = Context.Sql(@\"delete from Product\r\n                where ProductId = 1\")\r\n                .Execute();\r\n\r\n\\\r\nUsing a builder:\r\n\r\n    int rowsAffected = Context.Delete(\"Product\")\r\n                .Where(\"ProductId\", 1)\r\n                .Execute();\r\n\r\n\\\r\n**Stored procedure**\\\r\nUsing SQL:\r\n\r\n    var rowsAffected = Context.Sql(\"ProductUpdate\")\r\n                .CommandType(DbCommandTypes.StoredProcedure)\r\n                .Parameter(\"ProductId\", 1)\r\n                .Parameter(\"Name\", \"The Warren Buffet Way\")\r\n                .Execute();\r\n\r\n\\\r\nUsing a builder:\r\n\r\n    var rowsAffected = Context.StoredProcedure(\"ProductUpdate\")\r\n                .Parameter(\"Name\", \"The Warren Buffet Way\")\r\n                .Parameter(\"ProductId\", 1).Execute();\r\n\r\n\\\r\nUsing a builder with automapping:\r\n\r\n    var product = Context.Sql(\"select * from Product where ProductId = 1\")\r\n                .QuerySingle<Product>();\r\n\r\n    product.Name = \"The Warren Buffet Way\";\r\n\r\n    var rowsAffected = Context.StoredProcedure<Product>(\"ProductUpdate\", product)\r\n                .AutoMap(x => x.CategoryId).Execute();\r\n\r\n\\\r\nUsing a builder with automapping and expressions:\r\n\r\n    var product = Context.Sql(\"select * from Product where ProductId = 1\")\r\n                .QuerySingle<Product>();\r\n    product.Name = \"The Warren Buffet Way\";\r\n\r\n    var rowsAffected = Context.StoredProcedure<Product>(\"ProductUpdate\", product)\r\n                .Parameter(x => x.ProductId)\r\n                .Parameter(x => x.Name).Execute();\r\n\r\n\\\r\n**Transactions**\\\r\nFluentDAO supports transactions. When you use transactions its important to wrap the code inside a using statement to make sure that the database connection is closed. By default, if any exception occur or if Commit is not called then Rollback will automatically be called.\r\n\r\n    using (var context = Context.UseTransaction(true))\r\n    {\r\n        context.Sql(\"update Product set Name = @0 where ProductId = @1\")\r\n                    .Parameters(\"The Warren Buffet Way\", 1)\r\n                    .Execute();\r\n\r\n        context.Sql(\"update Product set Name = @0 where ProductId = @1\")\r\n                    .Parameters(\"Bill Gates Bio\", 2)\r\n                    .Execute();\r\n\r\n        context.Commit();\r\n    }\r\n\r\n\\\r\n**Entity factory**\\\r\nThe entity factory is responsible for creating object instances during automapping. If you have some complex business objects that require special actions during creation, you can create your own custom entity factory:\r\n\r\n    List<Product> products = Context.EntityFactory(new CustomEntityFactory())\r\n                .Sql(\"select * from Product\")\r\n                .QueryMany<Product>();\r\n\r\n    public class CustomEntityFactory : IEntityFactory\r\n    {\r\n        public virtual object Resolve(Type type)\r\n        {\r\n            return Activator.CreateInstance(type);\r\n        }\r\n    }","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}